<!DOCTYPE html>
<html>

<head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="MarkBind 2.14.1">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>CS2030 AY19/20 Semester 2</title>
  <link rel="stylesheet" href="../../../../markbind/css/bootstrap.min.css">
  <link rel="stylesheet" href="../../../../markbind/css/bootstrap-vue.min.css">
  <link rel="stylesheet" href="../../../../markbind/fontawesome/css/all.min.css">
  <link rel="stylesheet" href="../../../../markbind/glyphicons/css/bootstrap-glyphicons.min.css">
  <link rel="stylesheet" href="../../../../markbind/css/octicons.css">
  <link rel="stylesheet" href="../../../../markbind/css/github.min.css">
  <link rel="stylesheet" href="../../../../markbind/css/markbind.css">
  <link rel="stylesheet" href="/1920-s2/plugins/markbind-plugin-anchors/markbind-plugin-anchors.css">
  <link rel="stylesheet" href="../../../../markbind/layouts/default/styles.css">
  <link rel="stylesheet" href="../../../../markbind/css/page-nav.css">
</head>

<body data-spy="scroll" data-target="#page-nav" data-offset="100">
  <div id="app">
    <header>
      <navbar type="dark" class="temp-navbar">
        <a slot="brand" href="/1920-s2/index.html" title="Home" class="navbar-brand">CS2030 AY19/20 Semester 2</a>
        <div class="nav-link temp-dropdown-placeholder">Peer Learning</div>
        <dropdown class="nav-link temp-dropdown"><template slot="_header">Peer Learning</template>
          <li><a href="/1920-s2/contents/peerlearning/peerlearning.html" class="dropdown-item">Introduction</a></li>
          <li><a href="/1920-s2/contents/peerlearning/textbook.html" class="dropdown-item">Textbook Contributions</a></li>
          <li><a href="/1920-s2/contents/peerlearning/peerlearningtask.html" class="dropdown-item">Peer Learning Tasks</a></li>
          <li><a href="/1920-s2/contents/peerlearning/piazza.html" class="dropdown-item">Piazza Participation</a></li>
        </dropdown>
        <div class="nav-link temp-dropdown-placeholder">Guides</div>
        <dropdown class="nav-link temp-dropdown"><template slot="_header">Guides</template>
          <li><a href="/1920-s2/contents/guides/settingUpLabEnv.html" class="dropdown-item">Setting Up Lab Environment</a></li>
          <li><a href="/1920-s2/contents/guides/settingUpJava.html" class="dropdown-item">Setting Up Java</a></li>
          <li><a href="/1920-s2/contents/guides/settingUpVim.html" class="dropdown-item">Setting Up Vim</a></li>
          <li><a href="/1920-s2/contents/guides/settingUpMacVim.html" class="dropdown-item">Setting Up MacVim</a></li>
          <li><a href="/1920-s2/contents/guides/sunfireLabs.html" class="dropdown-item">Setting Up Sunfire and PE Nodes</a></li>
          <li><a href="/1920-s2/contents/guides/settingUpCheckstyle.html" class="dropdown-item">Setting Up Checkstyle</a></li>
        </dropdown>
        <li><a slot="brand" href="/1920-s2/contents/textbook/textbook.html" class="nav-link">Textbook</a></li>
        <div class="nav-link temp-dropdown-placeholder">Links</div>
        <dropdown class="nav-link temp-dropdown"><template slot="_header">Links</template>
          <li><a href="https://www.comp.nus.edu.sg/~cs2030/style/" class="dropdown-item" target="_blank">CS2030 Java Style Guide</a></li>
          <li><a href="https://www.comp.nus.edu.sg/~cs2030/javadoc/" class="dropdown-item" target="_blank">CS2030 Javadoc Specification</a></li>
          <li><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html" class="dropdown-item" target="_blank">JDK 11 Download Link</a></li>
          <li><a href="https://codecrunch.comp.nus.edu.sg/" class="dropdown-item" target="_blank">Codecrunch</a></li>
          <li><a href="https://github.com/nus-cs2030/1920-s2" class="dropdown-item" target="_blank">Github Repo</a></li>
          <li><a href="https://piazza.com/class/k54zo22zq1t2zc" class="dropdown-item" target="_blank">Piazza Forum</a></li>
        </dropdown>
        <li slot="right">
          <form class="navbar-form">
            <searchbar :data="searchData" placeholder="Search" :on-hit="searchCallback" menu-align-right></searchbar>
          </form>
        </li>
      </navbar>
    </header>
    <div id="flex-body">

      <div id="content-wrapper">
        <br>
        <h1 id="streams">Streams<a class="fa fa-anchor" href="#streams" onclick="event.stopPropagation()"></a></h1>
        <br>

        <p><a href="https://github.com/nus-cs2030/1920-s2/edit/master/contents/textbook/lecture08/Streams/pipelineAndLaziness.md">Edit the material here! <span aria-hidden="true" class="fas fa-pen"></span></a></p>

        <p>Streams is a new type of data structure introduced to us in lecture 8. Unlike previous data structures, streams are mainly used for
          functional programming, and we can often manipulate the data to get what we want in a single stream pipeline.</p>
        <h2 id="stream-pipeline">Stream Pipeline<a class="fa fa-anchor" href="#stream-pipeline" onclick="event.stopPropagation()"></a></h2>
        <p>A stream pipeline consists of a data source(e.g. generate/iterate), zero or more intermediate operations(e.g. map, filter) and a
          terminal operation(e.g. forEach) to end the pipeline. Once a terminal operation is called, the stream is consumed, and can no longer be
          used. An example of a stream pipeline:</p>
        <pre><code class="hljs java"><span><span class="hljs-keyword">int</span> sum = IntStream.range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>).map(x -&gt; x * <span class="hljs-number">2</span>).filter(x -&gt; x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).sum();<br></span><span><span class="hljs-comment">//IntStream.range(1, 10) is the data source</span><br></span><span><span class="hljs-comment">//map and filter are intermediate operations</span><br></span><span><span class="hljs-comment">//sum() is the terminal reduction that ends the stream pipeline</span><br></span></code></pre>
        <h2 id="laziness">Laziness<a class="fa fa-anchor" href="#laziness" onclick="event.stopPropagation()"></a></h2>
        <p>What differentiates streams from other data structures is that streams are lazy. Laziness in streams means that in a stream pipeline,
          intermediate operations are not evaluated until the terminal operation is called. Furthermore, the data from the data source is only
          generated and consumed when needed. Another example:</p>
        <pre><code class="hljs java"><span><span class="hljs-keyword">int</span> sum = IntStream.iterate(<span class="hljs-number">1</span>, x -&gt; x + <span class="hljs-number">1</span>).map(x -&gt; x * <span class="hljs-number">2</span>).filter(x -&gt; x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).forEach(System.out::println);<br></span><span><span class="hljs-comment">//(x -&gt; x * 2) is the Function&lt;T,T&gt; mapper</span><br></span><span><span class="hljs-comment">//(x -&gt; x * 2) is the Predicate&lt;T&gt;</span><br></span><span><span class="hljs-comment">//note this program runs forever since iterate creates an infinite stream</span><br></span></code></pre>
        <p>In the above example, when we do create the source with iterate, we create a IntStream object in the heap, which captures the value of
          seed and the UnaryOperator next. The rest of the values in the stream is not yet generated.
          <br>
          <br>
          When we go to intermediate operations map and filter, we create a new IntStream object in the heap, that captures the the mapper
          function that we input into the map function and a pointer to the previous IntStream object. At this point, the function mapper is not
          yet applied. Likewise for the filter operation, a new IntStream object is created in the heap, capturing the Predicate<t> and a pointer
            to the previous IntStream object created by map. Every intermediate operation in our pipeline will create a new stream object in the heap that captures the operation we want to do and a pointer to the previous stream object.
            <br>
            <br>
            Only when we call a terminal operation, in this case forEach, we follow the pointers upstream all the way to the source, get the current element, and apply all the intermediate operations downstream up to the terminal operation. We need to go through this upstream-downstream process for each element in the stream.
            <br>
            <br>
            As in Prof Henry's lecture 9 slides, this example illustrates the laziness in streams.</t>
        </p>
        <pre><code class="hljs java"><span><span class="hljs-keyword">int</span> sum = IntStream<br></span><span>  .rangeClosed(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br></span><span>  .filter(<br></span><span>    x -&gt; {<br></span><span>      System.out.println(<span class="hljs-string">"filter: "</span> + x);<br></span><span>      <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br></span><span>    })<br></span><span>  .map(<br></span><span>     x -&gt; {<br></span><span>      System.out.println(<span class="hljs-string">"map: "</span> + x);<br></span><span>      <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * x;<br></span><span>     })<br></span><span>  .sum();<br></span><span>System.out.println(sum);<br></span></code></pre>
        <p>This program prints:</p>
        <pre><code class="hljs"><span>filter: 1<br></span><span>filter: 2<br></span><span>map: 2<br></span><span>filter: 3<br></span><span>filter: 4<br></span><span>map: 4<br></span><span>filter: 5<br></span><span>filter: 6<br></span><span>map: 6<br></span><span>filter: 7<br></span><span>filter: 8<br></span><span>map: 8<br></span><span>filter: 9<br></span><span>filter: 10<br></span><span>map: 10<br></span><span>sum is 60<br></span></code></pre>
        <p>The output showing the filter and map interleaving with each other shows that the whole pipeline of intermediate operation is applied
          to one element at a time, as we would expect from the laziness of streams causing our evaluation process to go upstream and downstream
          for each element and only generating the element and applying the operations as we need. For contrast, if we were to use a List for the
          same program, the program would first filter the entire list, and then map the entire list, as opposed to applying the whole pipeline to
          one element at a time.</p>
        <h2 id="advantages-of-laziness">Advantages of Laziness<a class="fa fa-anchor" href="#advantages-of-laziness" onclick="event.stopPropagation()"></a></h2>
        <p>We can create incomplete stream pipelines with only intermediate operations and pass it around our program to be to continue adding more
          intermediate operations or to be consumed at a later time.
          <br>
          <br>
          In addition, since data elements are only generated and consumed when needed, we can create infinite streams. This is useful when we
          want to do things where we don't know how many elements we need in our data structure. For example, we can write a program to find the
          first 100 prime numbers. If we were to use a list, we would not know how big our initial list needs to be. Using streams, we can simply
          create an infinite stream, filter with a predicate to look for prime numbers and set a limit on the number of elements we want in the
          stream.</p>
        <h2 id="converting-between-streams-arrays-and-arraylists">Converting Between Streams, Arrays and ArrayLists<a class="fa fa-anchor" href="#converting-between-streams-arrays-and-arraylists" onclick="event.stopPropagation()"></a></h2>
        <p>From Array to ArrayList</p>
        <pre><code class="hljs java"><span><span class="hljs-keyword">import</span> java.util.Arrays;<br></span><span><span class="hljs-keyword">import</span> java.util.ArrayList;<br></span><span><span class="hljs-keyword">import</span> java.util.stream.IntStream;<br></span><span><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br></span><span><br></span><span><span class="hljs-comment">/*</span><br></span><span><span class="hljs-comment">Integer[] -&gt; ArrayList&lt;Integer&gt;</span><br></span><span><span class="hljs-comment">Works with any Object instead of Integer as well.</span><br></span><span><span class="hljs-comment">Does not work for primitive int[] array as Arrays.asList() method does not deal</span><br></span><span><span class="hljs-comment">with autoboxing and it will just create a List&lt;int[]&gt;</span><br></span><span><span class="hljs-comment">*/</span><br></span><span>Integer[] integerArray = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};<br></span><span>ArrayList&lt;Integer&gt; integerArrayList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(integerArray));<br></span><span><br></span><span><span class="hljs-comment">// int[] -&gt; ArrayList&lt;Integer&gt;</span><br></span><span><span class="hljs-keyword">int</span>[] intArray = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};<br></span><span><span class="hljs-comment">// boxed method converts primitive int to Integer</span><br></span><span>ArrayList&lt;Integer&gt; intArrayList = IntStream.of(intArray).boxed() <br></span><span>  .collect(Collectors.toCollection(ArrayList::<span class="hljs-keyword">new</span>));<br></span></code></pre>
        <p>From Array to Stream</p>
        <pre><code class="hljs java"><span><span class="hljs-comment">// Integer -&gt; Stream&lt;Integer&gt;</span><br></span><span>Integer[] integerArray = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};<br></span><span>Stream&lt;Integer&gt; integerStream = Arrays.stream(integerArray);<br></span><span><span class="hljs-comment">// int -&gt; IntStream</span><br></span><span><span class="hljs-keyword">int</span>[] intArray = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};<br></span><span>IntStream intStream = Arrays.stream(intArray);<br></span></code></pre>
        <p>From ArrayList to Array</p>
        <pre><code class="hljs java"><span><span class="hljs-comment">// ArrayList&lt;Integer&gt; -&gt; Integer[]</span><br></span><span>Integer[] integerArray = <span class="hljs-keyword">new</span> Integer[integerArrayList.size()];<br></span><span>integerArray = integerArrayList.toArray(integerArray);<br></span><span><span class="hljs-comment">// ArrayList&lt;Integer&gt; -&gt; int[]</span><br></span><span><span class="hljs-keyword">int</span>[] intArray = integerArrayList.stream().mapToInt(Integer::intValue).toArray();<br></span><span><span class="hljs-comment">// IntStream -&gt; int[]</span><br></span><span><span class="hljs-keyword">int</span>[] intArray = intStream.toArray();<br></span></code></pre>
        <p>From ArrayList to Stream</p>
        <pre><code class="hljs java"><span><span class="hljs-comment">// ArrayList&lt;Integer&gt; -&gt; Stream&lt;Integer&gt;</span><br></span><span>Stream&lt;Integer&gt; integerStream = integerArrayList.stream();<br></span><span><span class="hljs-comment">// ArrayList&lt;Integer&gt; -&gt; IntStream</span><br></span><span>IntStream intStream = integerArrayList.stream().mapToInt(Integer::intValue);<br></span></code></pre>
        <p>From Stream to Array</p>
        <pre><code class="hljs java"><span><span class="hljs-comment">// Stream&lt;Integer&gt; -&gt; Integer[]</span><br></span><span>Integer[] integerArray = integerStream.toArray(Integer[]::<span class="hljs-keyword">new</span>);<br></span><span><span class="hljs-comment">// intStream -&gt; int[]</span><br></span><span><span class="hljs-keyword">int</span>[] intArray = intStream.toArray();<br></span></code></pre>
        <p>From Stream to ArrayList</p>
        <pre><code class="hljs java"><span><span class="hljs-comment">// Stream&lt;Integer&gt; -&gt; ArrayList&lt;Integer&gt;</span><br></span><span>List&lt;Integer&gt; integerList = integerStream.collect(Collectors.toList());<br></span><span>ArrayList&lt;Integer&gt; integerArrayList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(integerList);<br></span><span><span class="hljs-comment">// intStream -&gt; ArrayList&lt;Integer&gt;</span><br></span><span>List&lt;Integer&gt; integerList = intStream.boxed().collect(Collectors.toList());<br></span><span>ArrayList&lt;Integer&gt; integerArrayList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(integerList);<br></span></code></pre>
        <h2 id="summary-for-streams">Summary for Streams<a class="fa fa-anchor" href="#summary-for-streams" onclick="event.stopPropagation()"></a></h2>
        <p>Here is a Summary for Streams that you can use during finals since there are so many methods for streams.</p>
        <p>Do note that these are not exhaustive but what I feel is the most common(for this course that is).</p>
        <div class="table-responsive">
          <table class="markbind-table table table-bordered table-striped">
            <thead>
              <tr>
                <th>Obtaining a Stream</th>
                <th>Intermediate Operations</th>
                <th>Terminal Operations</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><a href="#streamof"><code>Stream.of(...)</code></a></td>
                <td><a href="#filter"><code>filter(Predicate &lt;? super T&gt; pred)</code></a></td>
                <td><a href="#foreach-consumer-action"><code>forEach(Consumer&lt;? super T&gt; action</code></a></td>
              </tr>
              <tr>
                <td><a href="#streamof"><code>Stream.of(T t)</code></a></td>
                <td><a href="#map"><code>map(Function&lt;? super T, ? extends R&gt; mapper)</code></a></td>
                <td><a href="#converting-between-streams-arrays-and-arraylists"><code>toArray()</code></a></td>
              </tr>
              <tr>
                <td><a href="#streamgenerate"><code>Stream.generate(Supplier&lt;? extends T&gt; s)</code></a></td>
                <td><a href="#flatmap"><code>flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper)</code></a></td>
                <td><a href="#nonematch-allmatch-anymatchpredicate-super-t-predicate"><code>noneMatch(Predicate&lt;? super T&gt; pred)</code></a></td>
              </tr>
              <tr>
                <td><a href="#streamiterate"><code>Stream.iterate(T seed, UnaryOperator&lt;T&gt; next)</code></a></td>
                <td><a href="#sorted"><code>sorted()</code></a></td>
                <td><a href="#nonematch-allmatch-anymatchpredicate-super-t-predicate"><code>allMatch(Predicate&lt;? super T&gt; pred)</code></a></td>
              </tr>
              <tr>
                <td><a href="#streamiterate"><code>Stream.iterate(T seed, Predicate &lt;? super T&gt; hasNext, UnaryOperator&lt;T&gt; next)</code></a></td>
                <td><a href="#limitlong-maxsize"><code>limit(long maxSize)</code></a></td>
                <td><a href="#nonematch-allmatch-anymatchpredicate-predicate"><code>anyMatch(Predicate&lt;? super T&gt; predicate)</code></a></td>
              </tr>
              <tr>
                <td><a href="#streamconcat"><code>Stream.concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</code></a></td>
                <td><a href="#skiplong-n"><code>skip(long n)</code></a></td>
                <td><a href="#count"><code>count()</code></a></td>
              </tr>
              <tr>
                <td><a href="#intstreamrangeclosed--intstreamrange"><code>IntStream.rangeClosed(int startInclusive, int endInclusive)</code></a></td>
                <td><a href="#distinct"><code>distinct()</code></a></td>
                <td><a href="#min-and-max"><code>min(Comparator&lt;? super T&gt; comparator)/ max(Comparator&lt;? super T&gt; comparator)</code></a></td>
              </tr>
              <tr>
                <td><a href="#intstreamrangeclosed--intstreamrange"><code>IntStream.ranged(int startInclusive, int endInclusive)</code></a></td>
                <td><a href="#maptoobj-maptolong-maptodouble"><code>mapToObj/mapToInt/mapToLong</code></a></td>
                <td><a href="#min-and-max"><code>reduce(BinaryOperator&lt;T&gt; accumulator)</code></a></td>
              </tr>
              <tr>
                <td></td>
                <td><a href="#peek-consumer-action"><code>peek(Consumer&lt;? super T&gt; action)</code></a></td>
                <td><a href="#reduce"><code>reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code></a></td>
              </tr>
              <tr>
                <td></td>
                <td></td>
                <td><a href="#converting-between-streams-arrays-and-arraylists"><code>collect(Collector&lt;? super T,A,R&gt; collector)</code></a></td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>Also, the Stream API is <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Stream.html">here</a> and IntStream is <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/IntStream.html">here</a></p>
        <h4 id="stream-of">Stream.of<a class="fa fa-anchor" href="#stream-of" onclick="event.stopPropagation()"></a></h4>
        <p>Making a Stream out of individual values or an array or a list.
          <br></p>
        <pre><code class="hljs java"><span><span class="hljs-comment">//From a bunch of digits</span><br></span><span>Stream&lt;Integer&gt; stream = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>);<br></span><span><br></span><span><span class="hljs-comment">//From an array</span><br></span><span>Stream&lt;String&gt; stream = Stream.of(myArray)<br></span><span><br></span><span><span class="hljs-comment">// From a list (need to import java list)</span><br></span><span>list.stream(); <span class="hljs-comment">// or from a list</span><br></span></code></pre><br>
        <p><a href="#summary-for-streams">back to summary</a></p>
        <h4 id="stream-generate">Stream.generate<a class="fa fa-anchor" href="#stream-generate" onclick="event.stopPropagation()"></a></h4>
        <p>Returns an infinite sequential unordered stream where each element is generated by the provided Supplier.
          Do note that these are infinite Streams and thus, would need a .limit() terminal function.</p>
        <pre><code class="hljs java"><span><span class="hljs-comment">// just some examples</span><br></span><span><span class="hljs-comment">// creating a strean of the words "test" 10 times. </span><br></span><span>Stream&lt;String&gt; stream = Stream.generate(() -&gt; <span class="hljs-string">"test"</span>).limit(<span class="hljs-number">10</span>);<br></span><span><br></span><span><span class="hljs-comment">// creating a stream of random numbers</span><br></span><span>Stream.generate(<span class="hljs-keyword">new</span> Random()::nextInt).limit(<span class="hljs-number">5</span>).forEach(System.out::println);<br></span></code></pre><br>
        <p><a href="#summary-for-streams">back to summary</a></p>
        <h4 id="stream-iterate">Stream.iterate<a class="fa fa-anchor" href="#stream-iterate" onclick="event.stopPropagation()"></a></h4>
        <p>Returns an infinite sequential ordered Stream produced by iterative application of a function f to an initial element seed, producing a Stream consisting of seed, f(seed), f(f(seed)), etc.
          It takes in a seed and a unaryoperator</p>
        <pre><code class="hljs java"><span><span class="hljs-comment">// starts from 0</span><br></span><span>Stream&lt;Integer&gt; integers = Stream.iterate(<span class="hljs-number">0</span>, n -&gt; n + <span class="hljs-number">1</span>);<br></span><span><br></span><span><span class="hljs-comment">// starts from 2</span><br></span><span>IntStream.iterate(<span class="hljs-number">2</span>, x -&gt; x + <span class="hljs-number">1</span>)<br></span></code></pre>
        <p>Furthermore, there is also another type of iterate, where it can iterate and create a new element, but it has to satisfy the hasNext predicate. The first element will be the supplied seed value, the next element will be the result of applying the next function to the seed value, and so on iteratively until the hasNext predicate indicates that the stream should terminate. Do note if the seed does not pass the predicate, the stream will be empty.</p>
        <pre><code class="hljs java"><span>Stream.iterate(<span class="hljs-number">1</span>, i -&gt; i &lt;= <span class="hljs-number">20</span>, i -&gt; i * <span class="hljs-number">2</span>).forEach(System.out::println); <br></span><span><span class="hljs-comment">// output willl be 1,2,4,8,16</span><br></span><span><br></span><span>Stream.iterate(<span class="hljs-number">1</span>, i -&gt; i&lt;<span class="hljs-number">0</span>, i-&gt; i-<span class="hljs-number">1</span>).forEach(System.out::println);<br></span><span><span class="hljs-comment">// no output since there the first seed would not pass the predicate.</span><br></span></code></pre><br>
        <p><a href="#summary-for-streams">back to summary</a></p>
        <h4 id="stream-concat">Stream.concat<a class="fa fa-anchor" href="#stream-concat" onclick="event.stopPropagation()"></a></h4>
        <p>Stream.concat method creates a concatenated stream in which the elements are all the elements of the first stream followed by all the elements of the second stream. The resulting stream is ordered if both of the input streams are ordered.</p>
        <pre><code class="hljs java"><span><span class="hljs-comment">// Creating 2 streams</span><br></span><span>Stream&lt;String&gt; stream1 = Stream.of(<span class="hljs-string">"I"</span>, <span class="hljs-string">"hate"</span>); <br></span><span>Stream&lt;String&gt; stream2 = Stream.of(<span class="hljs-string">"circuit"</span>, <span class="hljs-string">"breaker"</span>);<br></span><span><br></span><span><span class="hljs-comment">//Concating them and displaying the result</span><br></span><span>Stream.concat(stream1, stream2).forEach(element -&gt; System.out.println(element)); <br></span><span><span class="hljs-comment">// I</span><br></span><span><span class="hljs-comment">// hate</span><br></span><span><span class="hljs-comment">// circuit</span><br></span><span><span class="hljs-comment">// breaker</span><br></span></code></pre><br>
        <p><a href="#summary-for-streams">back to summary</a></p>
        <h4 id="intstream-rangeclosed-intstream-range">IntStream.rangeClosed / IntStream.range<a class="fa fa-anchor" href="#intstream-rangeclosed-intstream-range" onclick="event.stopPropagation()"></a></h4>
        <p>IntStream range(int startInclusive, int endExclusive) returns a sequential ordered IntStream from startInclusive (inclusive) to endExclusive (exclusive) by an incremental step of 1.
          <br>
          IntStream rangeClosed(int startInclusive, int endInclusive) returns an IntStream from startInclusive (inclusive) to endInclusive (inclusive) by an incremental step of 1.</p>
        <pre><code class="hljs java"><span>IntStream stream = IntStream.rangeClosed(-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></span><span><span class="hljs-comment">// produces -1, 0, 1, 2</span><br></span><span>IntStream stream = IntStream.range(-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></span><span><span class="hljs-comment">// produces -1, 0, 1</span><br></span></code></pre><br>
        <p><a href="#summary-for-streams">back to summary</a></p>
        <h4 id="filter">filter<a class="fa fa-anchor" href="#filter" onclick="event.stopPropagation()"></a></h4>
        <p>Returns a stream consisting of the elements of this stream that match the given predicate.</p>
        <pre><code class="hljs java"><span>Stream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>).filter(x -&gt; x &lt; <span class="hljs-number">3</span>);<br></span><span><span class="hljs-comment">// 1, 2</span><br></span><span><br></span><span>IntStream.rangeClosed(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>).filter(x -&gt; x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).forEach(System.out::println);<br></span><span><span class="hljs-comment">// 2 4 6 8 10</span><br></span></code></pre><br>
        <p><a href="#summary-for-streams">back to summary</a></p>
        <h4 id="map">map<a class="fa fa-anchor" href="#map" onclick="event.stopPropagation()"></a></h4>
        <p>Applying a function to each element</p>
        <pre><code class="hljs java"><span>IntStream.rangeClosed(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>).map(x -&gt; x + <span class="hljs-number">1</span>);<br></span><span><span class="hljs-comment">// 2 3 4 5 </span><br></span></code></pre><br>
        <p><a href="#summary-for-streams">back to summary</a></p>
        <h4 id="maptoobj-maptolong-maptodouble">maptoObj/ maptoLong/ maptoDouble<a class="fa fa-anchor" href="#maptoobj-maptolong-maptodouble" onclick="event.stopPropagation()"></a></h4>
        <p>Do note that mapToObj is only present in IntStream/LongStream but not in the primitive Stream.
          This is because a Stream itself is already a stream of objects.
          Use mapToX (mapToObj, mapToDouble, etc.) if the function yields Object, double, etc. values.</p>
        <pre><code class="hljs java"><span><span class="hljs-comment">// creates a bunch of circles as per lecture notes</span><br></span><span>Stream&lt;Circle&gt; circles = IntStream.rangeClosed(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>).mapToObj(Circle::<span class="hljs-keyword">new</span>);<br></span><span><br></span><span><span class="hljs-comment">// From the midterms 2, mapping all the values in the rangeClosed to a String(you cant see the difference if you just print it)</span><br></span><span>IntStream.rangeClosed(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>).mapToObj(x -&gt;x + <span class="hljs-string">""</span>).forEach(System.out::println);<br></span></code></pre><br>
        <p><a href="#summary-for-streams">back to summary</a></p>
        <h4 id="flatmap">flatmap<a class="fa fa-anchor" href="#flatmap" onclick="event.stopPropagation()"></a></h4>
        <p>Stream flatMap(Function mapper) returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element. flatMap() is the combination of a map and a flat operation i.e, it applies a function to elements as well as flatten them.</p>
        <pre><code class="hljs java"><span><br></span><span><span class="hljs-comment">// Present in the lecture notes as well. </span><br></span><span>IntStream.rangeClosed(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>).flatMap(x -&gt; IntStream.rangeClosed(<span class="hljs-number">1</span>,x)).forEach(System.out::println);<br></span><span><span class="hljs-comment">//1 1 2 1 2 3</span><br></span><span><span class="hljs-comment">//</span><br></span></code></pre>
        <p>Similarly, there are also flatMaptoDouble/Int/Long. There isnt a flatmaptoObj but you can just do a workaround by combining mapToObj and flatMap.
          <br></p>
        <p><a href="#summary-for-streams">back to summary</a></p>
        <h4 id="sorted">sorted()<a class="fa fa-anchor" href="#sorted" onclick="event.stopPropagation()"></a></h4>
        <p>Stream sorted() returns a stream consisting of the elements of this stream, sorted according to natural order. For ordered streams, the sort method is stable but for unordered streams, no stability is guaranteed.
          It can also take in a comparator to sort objects that are passed into Streams.</p>
        <pre><code class="hljs java"><span>IntStream.of(<span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>).sorted().forEach(System.out::println);<br></span><span><span class="hljs-comment">//sorts the stream accordingly </span><br></span></code></pre><br>
        <p><a href="#summary-for-streams">back to summary</a></p>
        <h4 id="limit-long-maxsize">limit(long maxSize)<a class="fa fa-anchor" href="#limit-long-maxsize" onclick="event.stopPropagation()"></a></h4>
        <p>Returns a stream consisting of the elements of this stream, truncated to be no longer than maxSize in length.</p>
        <pre><code class="hljs java"><span>IntStream.iterate(<span class="hljs-number">2</span>, x -&gt; x + <span class="hljs-number">2</span>).limit(<span class="hljs-number">5</span>).forEach(System.out::println);<br></span><span><span class="hljs-comment">//produces 2 4 6 8 10</span><br></span></code></pre><br>
        <p><a href="#summary-for-streams">back to summary</a></p>
        <h4 id="distinct">distinct()<a class="fa fa-anchor" href="#distinct" onclick="event.stopPropagation()"></a></h4>
        <p>distinct() returns a stream consisting of distinct elements in a stream. distinct() is the method of Stream interface. This method uses hashCode() and equals() methods to get distinct elements.</p>
        <pre><code class="hljs java"><span>IntStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>).distinct().forEach(System.out::println);<br></span><span><span class="hljs-comment">// 1 0</span><br></span></code></pre><br>
        <p><a href="#summary-for-streams">back to summary</a></p>
        <h4 id="skip-long-n">skip(long n)<a class="fa fa-anchor" href="#skip-long-n" onclick="event.stopPropagation()"></a></h4>
        <p>The skip(long N) is a method of java.util.stream.Stream object. This method takes one long (N) as an argument and returns a stream after removing first N elements.</p>
        <pre><code class="hljs java"><span>IntStream.iterate(<span class="hljs-number">2</span>, x -&gt; x + <span class="hljs-number">2</span>).skip(<span class="hljs-number">2</span>).limit(<span class="hljs-number">5</span>).forEach(System.out::println);<br></span><span><span class="hljs-comment">// 6 8 10 12 14 (it skips the first 2 and 4)</span><br></span></code></pre><br>
        <p><a href="#summary-for-streams">back to summary</a></p>
        <h4 id="peek-consumer-action">peek(Consumer action)<a class="fa fa-anchor" href="#peek-consumer-action" onclick="event.stopPropagation()"></a></h4>
        <p>Stream peek(Consumer action) returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream. This is an intermediate operation i.e, it creates a new stream that, when traversed, contains the elements of the initial stream that match the given predicate. Therefore, using peek without any terminal operation would do nothing.
          <br>
          This method exists mainly to support debugging, where you want to see the elements as they flow past a certain point in a pipeline.</p>
        <pre><code class="hljs java"><span><span class="hljs-comment">/// no output because there is no terminal operation. </span><br></span><span>IntStream.iterate(<span class="hljs-number">2</span>, x -&gt; x + <span class="hljs-number">2</span>).limit(<span class="hljs-number">5</span>).peek(System.out::println);<br></span><span><br></span><span><span class="hljs-comment">// </span><br></span><span>IntStream.iterate(<span class="hljs-number">2</span>, x -&gt; x + <span class="hljs-number">2</span>).limit(<span class="hljs-number">5</span>).peek(System.out::println).count();<br></span><span><span class="hljs-comment">// 2 4 6 8 10 </span><br></span><span><span class="hljs-comment">// returns 5</span><br></span></code></pre><br>
        <p><a href="#summary-for-streams">back to summary</a></p>
        <h4 id="foreach-consumer-action">forEach(Consumer action)<a class="fa fa-anchor" href="#foreach-consumer-action" onclick="event.stopPropagation()"></a></h4>
        <p>Performs an action for each element of this stream. It is a terminal operation.</p>
        <pre><code class="hljs java"><span>IntStream.range(<span class="hljs-number">4</span>, <span class="hljs-number">9</span>).forEach(System.out::println); <br></span><span><span class="hljs-comment">// 4 5 6 7 8 </span><br></span></code></pre><br>
        <p><a href="#summary-for-streams">back to summary</a></p>
        <h4 id="nonematch-allmatch-anymatch-predicate-predicate">noneMatch/ allMatch/ anyMatch(Predicate predicate)<a class="fa fa-anchor" href="#nonematch-allmatch-anymatch-predicate-predicate" onclick="event.stopPropagation()"></a></h4>
        <p>These operations return a boolean result.
          noneMatch returns true if none of the elements pass the given predicate
          allMatch returns true if every element passes the given predicate
          anyMatch returns true if at least one element passes the given predicate</p>
        <pre><code class="hljs java"><span>IntStream.range(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>).noneMatch(x -&gt; <span class="hljs-number">5</span> % x == <span class="hljs-number">0</span>); <span class="hljs-comment">// true</span><br></span><span>IntStream.range(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>).allMatch(x -&gt; <span class="hljs-number">5</span> % x == <span class="hljs-number">0</span>); <span class="hljs-comment">// false</span><br></span><span>IntStream.range(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>).anyMatch(x -&gt; <span class="hljs-number">5</span> % x == <span class="hljs-number">0</span>); <span class="hljs-comment">// false</span><br></span><span><br></span><span><span class="hljs-comment">// if we replace 5 with 6</span><br></span><span><span class="hljs-comment">// we will get false false true. </span><br></span></code></pre><br>
        <p><a href="#summary-for-streams">back to summary</a></p>
        <h4 id="count">count()<a class="fa fa-anchor" href="#count" onclick="event.stopPropagation()"></a></h4>
        <p>Returns the count of elements in the stream as a long. It is a terminal operation</p>
        <pre><code class="hljs java"><span>IntStream.rangeClosed(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>).count();<br></span><span><span class="hljs-comment">// returns 10. Note that this 10 is of long type. </span><br></span></code></pre><br>
        <p><a href="#summary-for-streams">back to summary</a></p>
        <h4 id="reduce">reduce<a class="fa fa-anchor" href="#reduce" onclick="event.stopPropagation()"></a></h4>
        <p>reduce(T identity, BinaryOperator<t> accumulator)
            <br>
            Performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value. First argument to reduce is the operationâ€™s identity value, Second argument is the lambda that receives two
            values and performs the accumulator onto them.</t>
        </p>
        <pre><code class="hljs java"><span>IntStream.rangeClosed(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>).reduce(<span class="hljs-number">1</span>, (x, y) -&gt; x + y);<br></span><span><span class="hljs-comment">// this basically sums the entire thing up. BUT it starts with the seed of 1</span><br></span><span><span class="hljs-comment">// so it is 1+3+4+5+6</span><br></span></code></pre>
        <p>There is another version of reduce that does not take in an identity/seed. It performs a reduction on the elements of this stream, using an associative accumulation function, and returns an Optional describing the reduced value, if any.
          <br>
          NOTE: that this returns an Optional. This is because the calculation will start from the first element of the Stream(the first element will be treated as the seed). But there is also
          the possibility that the stream is Empty. In that case, it will return an Optional.</p>
        <pre><code class="hljs java"><span>IntStream.rangeClosed(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>).reduce((x, y) -&gt; x + y);<br></span><span><span class="hljs-comment">// this will produce an optional of 3 + 4 + 5 + 6 which is Optional(18)</span><br></span><span><br></span><span><span class="hljs-comment">//However, if we input an empty stream</span><br></span><span>IntStream.rangeClosed(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>).filter(x -&gt; x &lt; <span class="hljs-number">2</span>).reduce((x,y)-&gt; x+y)<br></span><span><span class="hljs-comment">// you will get an optional empty</span><br></span><span><br></span><span><span class="hljs-comment">//If there is only 1 element</span><br></span><span>IntStream.rangeClosed(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>).reduce((x,y)-&gt; x+y)<br></span><span><span class="hljs-comment">// you will get the only element, optional(3)</span><br></span><span><br></span><span><span class="hljs-comment">// useful way to get the last element of the stream</span><br></span><span>IntStream.rangeClosed(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>).reduce((x,y)-&gt;y)<br></span><span><span class="hljs-comment">//Optional[6]</span><br></span></code></pre><br>
        <p><a href="#summary-for-streams">back to summary</a></p>
        <h4 id="min-and-max">.min() and .max()<a class="fa fa-anchor" href="#min-and-max" onclick="event.stopPropagation()"></a></h4>
        <p>Stream.min() returns the optional containing the minimum element of the stream based on the provided Comparator. You can skip using a comparator if the stream is an IntStream as it will return according to the natural ordering. max returns the largest element.</p>
        <pre><code class="hljs java"><span>IntStream.rangeClosed(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>).min()<br></span><span><span class="hljs-comment">// returns Optional[3]</span><br></span><span><br></span><span><span class="hljs-comment">// using a comparator for a normal stream</span><br></span><span>List&lt;Integer&gt; list = Arrays.asList(-<span class="hljs-number">9</span>, -<span class="hljs-number">18</span>, <span class="hljs-number">0</span>, <span class="hljs-number">25</span>, <span class="hljs-number">4</span>); <br></span><span>Integer <span class="hljs-keyword">var</span> = list.stream().min(Integer::compare).get(); <span class="hljs-comment">//get used to get the number out of the optional.</span><br></span><span><br></span><span><span class="hljs-comment">// returns -18</span><br></span></code></pre><br>
        <p><a href="#summary-for-streams">back to summary</a></p>
        <h4 id="collect-and-toarray">Collect and toArray()<a class="fa fa-anchor" href="#collect-and-toarray" onclick="event.stopPropagation()"></a></h4>
        <p>The uses of collect and toArray are explained in the converting from stream to array or stream to list.
          <br></p>
        <p><a href="#summary-for-streams">back to summary</a></p>
        <p></p>
      </div>


      <nav id="page-nav" class="navbar navbar-light bg-transparent">
        <div class="border-left-grey nav-inner position-sticky slim-scroll">

          <nav class="nav nav-pills flex-column my-0 small no-flex-wrap">
            <a class="nav-link py-1" href="#streams">Streams&#x200E;</a>
            <nav class="nav nav-pills flex-column my-0 nested no-flex-wrap">
              <a class="nav-link py-1" href="#stream-pipeline">Stream Pipeline&#x200E;</a>
              <a class="nav-link py-1" href="#laziness">Laziness&#x200E;</a>
              <a class="nav-link py-1" href="#advantages-of-laziness">Advantages of Laziness&#x200E;</a>
              <a class="nav-link py-1" href="#converting-between-streams-arrays-and-arraylists">Converting Between Streams, Arrays and ArrayLists&#x200E;</a>
              <a class="nav-link py-1" href="#summary-for-streams">Summary for Streams&#x200E;</a>
            </nav>

          </nav>
        </div>
      </nav>
    </div>
    <footer>

      <div class="text-center">
        <small>Generated by <a href="https://markbind.org/">MarkBind 2.14.1</a> on Fri, Apr 24, 2020, 6:38:32 AM UTC</small></div>
    </footer>
  </div>
</body>
<script src="../../../../markbind/js/vue.min.js"></script>
<script src="../../../../markbind/js/vue-strap.min.js"></script>
<script src="../../../../markbind/js/bootstrap-utility.min.js"></script>
<script src="../../../../markbind/js/polyfill.min.js"></script>
<script src="../../../../markbind/js/bootstrap-vue.min.js"></script>
<script>
  const baseUrl = '/1920-s2'
  const enableSearch = true
</script>
<script src="../../../../markbind/js/setup.js"></script>
<script src="../../../../markbind/layouts/default/scripts.js"></script>

</html>